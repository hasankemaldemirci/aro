import fs from "fs";
import path from "path";
import os from "os";

describe("Refactor Module - Pattern Detection", () => {
  test("should detect multiple classes in content", () => {
    const content = `
export class UserService {
  getUser() {}
}

export class ProductService {
  getProduct() {}
}

export class OrderService {
  getOrder() {}
}
`;

    const classMatches = content.match(/(?:export\s+)?class\s+(\w+)/g);
    expect(classMatches).toBeDefined();
    expect(classMatches!.length).toBe(3);
  });

  test("should detect type definitions in content", () => {
    const content = `
export interface User {
  id: string;
}

export interface Product {
  id: string;
}

export type UserRole = 'admin' | 'user';
export type ProductCategory = 'electronics';
`;

    const interfaceMatches = content.match(/(?:export\s+)?interface\s+(\w+)/g);
    const typeMatches = content.match(/(?:export\s+)?type\s+(\w+)/g);

    expect(interfaceMatches!.length).toBe(2);
    expect(typeMatches!.length).toBe(2);
  });

  test("should detect function definitions in content", () => {
    const content = `
export function validateEmail(email: string) {}
export function validatePassword(password: string) {}
const hashPassword = (password: string) => {};
const generateToken = async () => {};
`;

    const functionMatches = content.match(
      /(?:export\s+)?(?:async\s+)?function\s+(\w+)|(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s*)?\(/g,
    );

    expect(functionMatches).toBeDefined();
    expect(functionMatches!.length).toBeGreaterThanOrEqual(4);
  });

  test("should count lines correctly", () => {
    const content = "line1\nline2\nline3\nline4\nline5";
    const lines = content.split("\n");
    expect(lines.length).toBe(5);
  });
});

describe("Refactor Module - File Operations", () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "aro-refactor-test-"));
  });

  afterEach(() => {
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  test("should create markdown report with correct structure", () => {
    const reportContent = `# ARO Refactoring Suggestions

**Generated:** 2026-02-17T16:00:00.000Z

**Summary:** Found 1 file(s) exceeding 300 lines that need refactoring.

---

## ðŸ“„ \`test.ts\` (350 lines)

### Recommended Actions:

- Split 2 classes into separate files
- Extract 4 type definitions

---

*Generated by ARO (Agent Readability Optimizer)*
`;

    const reportPath = path.join(tempDir, "ARO-REFACTOR-PLAN.md");
    fs.writeFileSync(reportPath, reportContent);

    expect(fs.existsSync(reportPath)).toBe(true);
    const content = fs.readFileSync(reportPath, "utf8");
    expect(content).toContain("ARO Refactoring Suggestions");
    expect(content).toContain("test.ts");
    expect(content).toContain("Recommended Actions");
  });

  test("should split multiple classes into separate files", () => {
    const multiClassContent = `export class UserService {
  getUser() {}
  updateUser() {}
}

export class ProductService {
  getProduct() {}
  updateProduct() {}
}

export class OrderService {
  getOrder() {}
}`;

    const testFile = path.join(tempDir, "services.ts");
    fs.writeFileSync(testFile, multiClassContent);

    // Simulate applyRefactoring logic
    const classMatches = multiClassContent.match(
      /(?:export\s+)?class\s+(\w+)[\s\S]*?(?=(?:export\s+)?class\s+\w+|$)/g,
    );

    expect(classMatches).toBeDefined();
    expect(classMatches!.length).toBe(3);

    // Verify we can extract class names
    const classNames = classMatches!.map((c) => {
      const match = c.match(/class\s+(\w+)/);
      return match ? match[1] : null;
    });

    expect(classNames).toEqual([
      "UserService",
      "ProductService",
      "OrderService",
    ]);
  });

  test("should extract type definitions", () => {
    const typeContent = `export interface User {
  id: string;
  name: string;
}

export interface Product {
  id: string;
  price: number;
}

export type UserRole = 'admin' | 'user';
export type ProductCategory = 'electronics';`;

    const typeMatches = typeContent.match(
      /(?:export\s+)?(?:interface|type)\s+\w+[\s\S]*?(?=\n(?:export\s+)?(?:interface|type|class|function|const|let|var)|$)/g,
    );

    expect(typeMatches).toBeDefined();
    expect(typeMatches!.length).toBeGreaterThanOrEqual(4);
  });

  test("should create backup file when applying refactoring", () => {
    const originalContent = `export class TestClass {
  test() {}
}`;

    const testFile = path.join(tempDir, "test.ts");
    fs.writeFileSync(testFile, originalContent);

    // Simulate backup creation
    const backupPath = testFile + ".aro-backup";
    fs.writeFileSync(backupPath, originalContent);

    expect(fs.existsSync(backupPath)).toBe(true);
    expect(fs.readFileSync(backupPath, "utf8")).toBe(originalContent);
  });

  test("should handle files with mixed classes and types", () => {
    const mixedContent = `export interface User {
  id: string;
}

export class UserService {
  getUser() {}
}

export type UserRole = 'admin' | 'user';

export class ProductService {
  getProduct() {}
}`;

    const classMatches = mixedContent.match(/(?:export\s+)?class\s+(\w+)/g);
    const typeMatches = mixedContent.match(
      /(?:export\s+)?(?:interface|type)\s+(\w+)/g,
    );

    expect(classMatches!.length).toBe(2);
    expect(typeMatches!.length).toBe(2);
  });
});
