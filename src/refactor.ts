import fs from "fs";
import path from "path";
import fg from "fast-glob";
import { Branding } from "./constants";
import { loadIgnoreList } from "./utils";

/**
 * @aro-context-marker
 * AI READABILITY NOTE: Refactor Analysis Module.
 * Analyzes large files and provides intelligent splitting suggestions.
 * Does NOT modify files - only analyzes and reports.
 */

export async function run() {
  const projectPath = process.cwd();
  const contextPath = path.join(projectPath, ".agent_context_pro.json");
  const ignoreList = loadIgnoreList(projectPath);

  // Check for --apply flag
  const shouldApply = process.argv.includes("--apply");

  if (!fs.existsSync(contextPath)) {
    console.log(
      Branding.error(
        "âŒ Error: No .agent_context_pro.json found. Run 'aro audit' first.",
      ),
    );
    process.exit(1);
  }

  console.log(
    Branding.magenta.bold(
      shouldApply
        ? "\nðŸ¤– ARO Agentic Refactor: Analyzing and applying optimizations..."
        : "\nðŸ” ARO Refactor Analysis: Scanning for optimization opportunities...",
    ),
  );

  // Scan for large files that need refactoring
  const filesToOptimize = fg.sync(["**/*.{js,ts,tsx,jsx}"], {
    cwd: projectPath,
    ignore: ignoreList.map((i) => `**/${i}/**`),
    absolute: true,
    deep: 5,
  });

  let largeFilesFound = 0;
  const refactorSuggestions: Array<{
    file: string;
    lines: number;
    suggestions: string[];
    content?: string;
  }> = [];

  for (const file of filesToOptimize) {
    const content = fs.readFileSync(file, "utf8");
    const lines = content.split("\n").length;

    if (lines > 300) {
      largeFilesFound++;
      const suggestions = analyzeFileStructure(file, content);
      refactorSuggestions.push({
        file: path.relative(projectPath, file),
        lines,
        suggestions,
        content: shouldApply ? content : undefined,
      });
    }
  }

  // Display refactoring suggestions
  if (refactorSuggestions.length > 0) {
    console.log(
      Branding.warning(
        `\nðŸ” Found ${largeFilesFound} file(s) exceeding 300 lines:\n`,
      ),
    );

    // Generate markdown report
    let markdownReport = `# ARO Refactoring Suggestions\n\n`;
    markdownReport += `**Generated:** ${new Date().toISOString()}\n\n`;
    markdownReport += `**Summary:** Found ${largeFilesFound} file(s) exceeding 300 lines that need refactoring.\n\n`;
    markdownReport += `---\n\n`;

    refactorSuggestions.forEach(({ file, lines, suggestions, content }) => {
      console.log(Branding.error(`ðŸ“„ ${file} (${lines} lines)`));

      // Add to markdown
      markdownReport += `## ðŸ“„ \`${file}\` (${lines} lines)\n\n`;
      markdownReport += `### Recommended Actions:\n\n`;

      suggestions.forEach((suggestion) => {
        console.log(Branding.gray(`   â†’ ${suggestion}`));
        markdownReport += `- ${suggestion}\n`;
      });

      console.log("");
      markdownReport += `\n`;

      // Apply refactoring if --apply flag is set
      if (shouldApply && content) {
        const filePath = path.join(projectPath, file);
        const appliedChanges = applyRefactoring(filePath, content, suggestions);
        if (appliedChanges.length > 0) {
          console.log(Branding.success(`   âœ… Applied refactoring:`));
          appliedChanges.forEach((change) => {
            console.log(Branding.gray(`      â€¢ ${change}`));
          });
          markdownReport += `\n**Applied Changes:**\n`;
          appliedChanges.forEach((change) => {
            markdownReport += `- âœ… ${change}\n`;
          });
          markdownReport += `\n`;
        }
      }
    });

    markdownReport += `---\n\n`;
    markdownReport += `*Generated by ARO (Agent Readability Optimizer)*\n`;

    // Write to file
    const reportPath = path.join(projectPath, "ARO-REFACTOR-PLAN.md");
    fs.writeFileSync(reportPath, markdownReport);
    console.log(
      Branding.success(`\nðŸ“ Refactoring plan saved to: ARO-REFACTOR-PLAN.md`),
    );

    if (shouldApply) {
      console.log(
        Branding.success(
          "\nâœ¨ Refactoring applied! Review the changes and run 'aro audit' to see updated scores.",
        ),
      );
    }
  } else {
    console.log(
      Branding.success(
        "\nâœ… No files exceeding 300 lines found. Your codebase is well-structured!",
      ),
    );
  }

  if (!shouldApply) {
    console.log(
      Branding.cyan(
        "\nðŸ’¡ Tip: Run 'aro refactor --apply' to automatically apply these suggestions.",
      ),
    );
  }
}

function applyRefactoring(
  filePath: string,
  content: string,
  suggestions: string[],
): string[] {
  const appliedChanges: string[] = [];
  const dir = path.dirname(filePath);
  const ext = path.extname(filePath);
  const baseName = path.basename(filePath, ext);

  // Strategy 1: Split multiple classes
  if (suggestions.some((s) => s.includes("classes into separate files"))) {
    const classMatches = content.match(
      /(?:export\s+)?class\s+(\w+)[\s\S]*?(?=(?:export\s+)?class\s+\w+|$)/g,
    );
    if (classMatches && classMatches.length > 1) {
      classMatches.forEach((classContent) => {
        const className = classContent.match(/class\s+(\w+)/)?.[1];
        if (className) {
          const newFilePath = path.join(dir, `${className}${ext}`);
          fs.writeFileSync(newFilePath, classContent.trim() + "\n");
          appliedChanges.push(`Created ${className}${ext}`);
        }
      });
      // Mark original file for review
      const reviewPath = filePath + ".aro-backup";
      fs.writeFileSync(reviewPath, content);
      appliedChanges.push(`Backed up original to ${baseName}${ext}.aro-backup`);
    }
  }

  // Strategy 2: Extract types/interfaces
  if (suggestions.some((s) => s.includes("type definitions"))) {
    const typeMatches = content.match(
      /(?:export\s+)?(?:interface|type)\s+\w+[\s\S]*?(?=\n(?:export\s+)?(?:interface|type|class|function|const|let|var)|$)/g,
    );
    if (typeMatches && typeMatches.length > 3) {
      const typesContent = typeMatches.join("\n\n");
      const typesFilePath = path.join(dir, `${baseName}.types${ext}`);
      fs.writeFileSync(typesFilePath, typesContent.trim() + "\n");
      appliedChanges.push(`Created ${baseName}.types${ext}`);
    }
  }

  return appliedChanges;
}

function analyzeFileStructure(filePath: string, content: string): string[] {
  const suggestions: string[] = [];
  const lines = content.split("\n");

  // Detect functions/methods
  const functionMatches = content.match(
    /(?:export\s+)?(?:async\s+)?function\s+(\w+)|(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s*)?\(/g,
  );
  const classMatches = content.match(/(?:export\s+)?class\s+(\w+)/g);
  const interfaceMatches = content.match(/(?:export\s+)?interface\s+(\w+)/g);
  const typeMatches = content.match(/(?:export\s+)?type\s+(\w+)/g);

  const functionCount = functionMatches?.length || 0;
  const classCount = classMatches?.length || 0;
  const interfaceCount = interfaceMatches?.length || 0;
  const typeCount = typeMatches?.length || 0;

  // Strategy 1: Multiple classes/interfaces
  if (classCount > 1) {
    suggestions.push(
      `Split ${classCount} classes into separate files (one class per file)`,
    );
  }

  if (interfaceCount + typeCount > 3) {
    suggestions.push(
      `Extract ${interfaceCount + typeCount} type definitions into a types.ts file`,
    );
  }

  // Strategy 2: Many utility functions
  if (functionCount > 5 && classCount === 0) {
    suggestions.push(
      `Split ${functionCount} utility functions into logical groups (e.g., utils/validation.ts, utils/formatting.ts)`,
    );
  }

  // Strategy 3: Mixed concerns
  if (functionCount > 3 && classCount > 0) {
    suggestions.push(
      "Separate helper functions from class definitions into a utils module",
    );
  }

  // Strategy 4: Generic advice
  if (suggestions.length === 0) {
    const midpoint = Math.floor(lines.length / 2);
    suggestions.push(
      `Consider splitting at logical boundaries (e.g., around line ${midpoint})`,
    );
    suggestions.push(
      "Group related functions/classes and extract them into separate modules",
    );
  }

  return suggestions;
}

if (require.main === module) {
  run();
}
